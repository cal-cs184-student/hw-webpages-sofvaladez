<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2026 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Name: Sofia Valadez </div>

		<br>

		Link to webpage: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp26">cs184.eecs.berkeley.edu/sp25</a>
		
		<br>

		Link to GitHub repository: (TODO) <a href=https://github.com/cal-cs184-student/hw1-rasterizer-qwrerty>sofia's hw1 repo</a>
		
		<!--
		<figure>
			<img src="lion.jpg" alt="Lion" style="width:50%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>
		-->

		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		This was my first experience with anything remotely related to computer graphics and 
		it was initally difficult for me to get used to the libraries. However, I had a lot of fun
		and definitely improved my understanding of class material. This assignment focused
		primarily on implementing antialiasing techniques (supersampling, pixel sampling, and level sampling), 
		though there was a section to solidify how matrices are used for transformations.

		<h2>Task 1: Drawing Single-Color Triangles</h2>
		<h3>Rasterizing Triangles</h3>
		For my implementation, I first created a boundary box using the given triangle points.
		Then, I iterated through the pixels in the box, checking if the center of the given pixel
		is within the triangle. If so, I would fill the pixel with the given color. 

		<h3>Resulting Image</h3>
		<figure>
			<img src="task1.png" alt="task 1: 5 triangles of varying colors and sizes" width="300px"/>
			<figcaption>Here, it is plain to see that while the larger triangles are not so rough,
				the thin triangles look jagged and very terrible.
			</figcaption>
		</figure>
		
		<h2>Task 2: Antialiasing by Supersampling</h2>
		As the name supersampling implies, my implementation of this task closely mirrors 
		the first. However, to incorporate the sampling rate <i>n</i>, I would sample <i>n</i>
		times inside of every pixel. After finishing, I would then take the average of the 'subpixel'
		colors to determine the color of the original pixels. This works to antialias my triangles
		because it smoothes out the edges of triangles, diminishing the previously jagged look.

		<p>
			The triangle corner is getting increasingly smoother as the sampling rate increases 
			because we are able to more accurately diminish the harsh pixel edges. 
		</p>
		
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="task2s1.png" width="400px"/>
				  <figcaption>Sampling rate: 1</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="task2s4.png" width="400px"/>
				  <figcaption>Sampling rate: 4</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="task2s16.png" width="400px"/>
				  <figcaption>Sampling rate: 16</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h2>Task 3: Transforms</h2>
		<figure>
			<img src="task3.png" alt="task 3: pastel colored robot" width="300px"/>
			<figcaption>
				This is a drawing of a pastel colored robot that is 
				supposed to be loosing its balance. 
			</figcaption>
		</figure>

		<h2>Task 4: Barycentric coordinates</h2>
		In this task, I implemented barycentric coordinates is how we 
		can use weight to describe the location of a point. This is especially 
		useful when mapping textures onto objects as we can derive the correct color, 
		texture, etc. for a specific point with this weighting system. 

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="task4tri.png" width="400px"/>
				  <figcaption>Blended triangle.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="task4wheel.png" width="400px"/>
				  <figcaption>Color wheel</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
		Pixel sampling is how we decide the color of a pixel from a texture provided. 
		After getting the barycentric coordinates for each pixel, I passed that to the texture 
		sampler, which will either use nearest or bilinear sampling. Nearest sampling 
		selects the texture pixel that is closest to the passed in coordinate and uses that 
		color. Bilinear sampling uses the surrounding 4 pixels to create a weighted result, 
		and interpolates through these pixels and returns a weighted average for the resulting color. 
		
		<br>

		For all of these images, it was really only possible to see a difference between 
		the different sampling techniques when you zoom into the images. When doing so, the 
		nearest neighbor sampling is much more pixelated than the bilinear sampling ones, even 
		when supersampling is applied. 

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="task5s1n.png" width="400px"/>
				  <figcaption>Sampling rate 1 and nearest sampling.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="task5s1l.png" width="400px"/>
				  <figcaption>Sampling rate 1 and bilinear sampling.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="task5s16n.png" width="400px"/>
				  <figcaption>Sampling rate 16 and nearest sampling.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="task5s16l.png" width="400px"/>
				  <figcaption>Sampling rate 16 and bilinear sampling.</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
		<h3>
			Implementation
		</h3>
		Level sampling is used for figuring out what mipmap level should be used 
		for a texture. If we know the size of the texture and how it will appear, 
		we can pre-compute a lower resolution texture to save computation. 
		Implementing this builds off previous tasks, so after interpolating coordinates, 
		we compute how much they will change in the screen space. Then, we estimate the 
		new mipmap level and how much the texture coordinates will change using the 
		passed in level.

		<h3>
			Tradeoffs
		</h3>
		Supersampling is easily the most expensive, since we have to sample multiple times 
		within just one sample, save this ‘higher resolution’ buffer, and then transfer 
		it to every pixel in the original frame buffer by averaging pixels in the previous 
		buffer. Though it does create the smoothest image, it is both slow and uses a lot 
		of memory. Both pixel sampling techniques are faster than supersampling and also do 
		not require the extra memory, as it will just pass through only one buffer. Though it
		is not as good as supersampling, it is still effective. Level sampling takes advantage
		of the passed in texture’s resolution, by precomputing levels, which adds to the runtime.
		It also needs to store the other mipmap levels, though this is not a significant amount of 
		memory usage. This is especially useful when the textures are low resolution. 

		<h3>
			Cat PNGs
		</h3>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="t6l0pn.png" width="400px"/>
				  <figcaption>L_ZERO, P_NEAREST. </figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="t6l0pl.png" width="400px"/>
				  <figcaption>L_ZERO, P_LINEAR.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="t6lnpn.png" width="400px"/>
				  <figcaption>L_NEAREST, P_NEAREST.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="t6lnpl.png" width="400px"/>
				  <figcaption>L_NEAREST, P_LINEAR.</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		
		<!--comment this out
			<h2>Additional Notes (please remove)</h2>
			<ul>
				<li>You can also add code if you'd like as so: <code>code code code</code></li>
				<li>If you'd like to add math equations, 
					<ul>
						<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
						<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
					</ul>
				</li>
			</ul>
		-->
		</div>
	</body>
</html>